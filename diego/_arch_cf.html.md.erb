This topic includes the following sections:

* [Introduction to Diego](#overview)
* [Diego Flow and Architecture Diagram](#diagram)
* [Diego Component Glossary](#core)
	* [Diego Cell Components](#cell-components)
	* [Diego Brain](#brain-components)
	* [Database VMs](#database-vms)
	* [Component Coordination](#component-coordination)

##<a id="overview"></a> Introduction to Diego

Diego is a self-healing container management system that attempts to keep the correct number of instances running in Diego Cells to avoid network failures and crashes. Diego schedules and runs Tasks and Long-Running Processes (LRP):

 * **Tasks** <br>
 Tasks run only once and terminate.

 * **LRPs** <br>
 LRPs may have multiple instances.

You can submit, update, and retrieve the desired number of Tasks and LRPs using the [Bulletin Board System (BBS) API](https://github.com/cloudfoundry/bbs).

For more about Tasks and LRPs, see [How the Diego Auction Allocates Jobs](diego-auction.html).

##<a id='diagram'></a> Diego Flow and Architecture Diagram


When you push an application to Cloud Foundry using Diego, Cloud Foundry will go through the following process:

 1. Cloud Foundry signals the Diego Brain to set up Auctioneer, which creates an auction based on the desired instances configured in BBS.
 1. The Executor creates a Garden container and executes the work encoded in the Tasks and LRPs. This work is encoded as a generic, platform-independent recipe of composable actions.
 1. The Converger periodically analyzes snapshots of this representation and corrects discrepancies, ensuring that Diego is eventually consistent.
 1. Diego sends real-time streaming logs for Tasks and LRPs to the [Loggregator](https://github.com/cloudfoundry/loggregator) system. Diego also registers its running LRP instances with the [Gorouter](https://github.com/cloudfoundry/gorouter) to route external web traffic to them.

<% if vars.product_name == 'CF' %>
<%= image_tag("../images/diego/diego-flow.png") %>
View a larger version of this image at the [Diego Design Notes repo](http://htmlpreview.github.io/?https://raw.githubusercontent.com/cloudfoundry-incubator/diego-design-notes/master/clickable-diego-overview/clickable-diego-overview.html).
<% else %>
<%= image_tag("../images/diego/diego-flow-other.png") %>
<% end %>



##<a id='core'></a>Diego Component Glossary##

The following summarizes the roles and responsibilities of the various components depicted in the Diego architecture diagram above.

<!-- * [Cells](#cell-components)
* [Brain](#brain-components)
* [Database VMs](#database-vms)
* [Access VMs](#access-vms)
* [Consul](#consul) -->

###<a id='cell-components'></a>Diego Cell Components ###

Diego Cell directly manages and maintains Tasks and LRPs with the following components:

 * <a id='rep'></a>**Rep** <br>
	* Maintains a presence record for the Cell in the BBS.
	* Participates in auctions to accept new Tasks and LRP instances.
	* Runs Tasks and LRPs by telling its in-process Executor to create a container and then to run actions in it.
	* Reacts to container events coming from the Executor.
	* Periodically ensures its set of Tasks and `ActualLRPs` in the BBS is in sync with the containers actually present on the Cell.
	* is concerned with Tasks and LRPs and knows details about their lifecycles.

 * <a id='executor'></a> **Executor** <br>
 	* Runs as a logical process inside the Rep
 	* Manages container allocations against resource constraints on the Cell, such as memory and disk space,
	* Implements the actions detailed in the API documentation,
	* Streams stdout and stderr from container processes to the metron-agent running on the Cell, which in turn forwards to the Loggregator system,
	* Periodically collects container metrics and emits them to Loggregator.
	* Knows only how to manage a collection of containers and to run actions in these containers

 * <a id="garden"></a> **Garden** <br>
	* Provides a platform-independent server and client to manage garden containers.
	* Defines an interface to be implemented by container-runners, such as guardian and garden-windows.
	* Knows nothing about actions and simply provides a concrete implementation of a platform-specific containerization technology that can run arbitrary commands in containers.

 * <a id='metron-agent'></a> **Metron Agent** <br>
 	Forwards application logs, errors, and application and Diego metrics to the [Loggregator](https://github.com/cloudfoundry/loggregator) Doppler component

###<a id='brain-components'></a> Diego Brain

Diego Brain components distribute Tasks and LRPs to Diego Cells, and correct discrepancies between Actual and Desired counts to ensure fault-tolerance and long-term consistency. The Diego Brain consists of the Auctioneer:

* <a id='auctioneer'></a> **Auctioneer** <br>
	* Holds auctions for Tasks and LRP instances.
	* Runs auctions using the auction package. Auction communication goes over HTTP and is between the Auctioneer and the Cell Reps.
	* Maintains a lock in consul to ensure only one auctioneer handles auctions at a time.
* <a id="converger"></a> **Converger** <br>
	The Converger maintains a lock in consul to ensure that only one converger performs convergence. This exclusivity is primarily for performance considerations, as convergence is idempotent. The compares `DesiredLRPs` and their `ActualLRPs` and takes action to enforce the desired state:
	* Resends auction requests for Tasks that have been pending for too long and completion callbacks for Tasks that have remained completed for too long,
	* Periodically sends aggregate metrics about DesiredLRPs, ActualLRPs, and Tasks to Loggregator.

###<a id='database-vms'></a>Database VMs ###

 * <a id='bbs'></a>**BBS** <br>
 BBS maintains a real-time representation of the state of the Diego cluster, including all desired LRPs, running LRP instances, and in-flight Tasks

 * <a id='mysql'></a>**MySQL** <br>
 MySQL provides a consistent key-value data store to Diego.

###<a id='access-vms'></a>Access VMs

 * <a id='file-server'></a>**File Server** <br>
 	The **File Server** serves static assets used by our various components, such as the App Lifecycle binaries.

 * <a id='ssh-proxy'></a>**SSH Proxy** <br>
	The SSH Proxy brokers connections between SSH clients and SSH servers running inside instance containers and authorizes access to CF app instances based on Cloud Controller roles.

###<a id='component-coordination'></a>Service Registration and Component Coordination

 * <a id="consul"></a>**Consul** <br>
	The Consul provides dynamic service registration and load-balancing via DNS resolution and a consistent key-value store for maintenance of distributed locks and component presence.
 * <a id="locket"></a> **Locket** <br>
	The Locket provides abstractions for locks and service registration that encapsulate interactions with consul.



