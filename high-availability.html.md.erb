---
title: High Availability Configurations
owner: Release Integration
---

<strong><%= modified_date %></strong>

This topic describes how to configure system components to ensure high availability. You accomplish this by scaling component VMs and locating them in multiple Availability Zones (AZs), so that their redundancy and distribution minimizes downtime during ongoing operation, product updates, and platform upgrades.

Scaling component VMs means changing the number of VM instances dedicated to running a functional component of the system. Scaling usually means increasing this number, while scaling down or scaling back means decreasing it.

For information about scaling applications and maintaining app uptime, see [Scaling an Application Using cf scale](../devguide/deploy-apps/cf-scale.html) and [Using Blue-Green Deployment to Reduce Downtime and Risk](devguide/deploy-apps/blue-green.html).

## <a id='capacity'></a>Scaling Platform Capacity for Applications ##

You can scale platform capacity vertically by adding memory and disk, or horizontally by adding more VMs running instances of Cloud Foundry components.

<%= image_tag("scale_cf.png", :height => "450px", :width => "475px") %>

Scaling up the following components increases your capacity to host applications. The nature of the applications you host on Cloud Foundry should determine whether you scale vertically or horizontally.

* **Diego cells**: The optimal balance between CPU/memory sizing and instance count depends on the performance characteristics of the apps that run on Diego cells. Scaling vertically with larger Diego cells makes for larger points of failure, and more apps go down when a cell fails. On the other hand, scaling horizontally decreases the speed at which the system rebalances apps. Rebalancing 100 cells takes longer and demands more processing overhead than rebalancing 20 cells.
* **Router**: Scale the router to accommodate the number of incoming requests. In general, this load is much less than the load on Diego cells.
* **Cloud Controller**: Scale the Cloud Controller to accommodate the number of requests to the API and the number of apps in the system.


## <a id='zero-downtime'></a>High Availability and Zero Downtime ##

During product updates and platform upgrades, the VMs in a deployment restart in succession, rendering them temporarily unavailable. During outages, VMs go down in a less orderly way. Spreading components across Availability Zones and scaling them to a sufficient level of redundancy maintains high availability during both upgrades and outages and can ensure zero downtime.

Deploying or scaling applications to at least two instances per app also helps maintain high availability. See [Scaling an Application Using cf scale](../devguide/deploy-apps/cf-scale.html) for information about scaling applications.

### <a id='azs'></a>Availability Zones

Deploying Cloud Foundry across three or more AZs and assigning multiple component instances to different AZ locations lets a deployment operate uninterrupted when entire AZs become unavailable. Cloud Foundry maintains its availability as long as a majority of the AZs remain accessible. For example, a three-AZ deployment stays up when one entire AZ goes down, and a five-AZ deployment can withstand an outage of up to two AZs with no impact on uptime.


### <a id='processes'></a>Scalable Components

You can scale most Cloud Foundry components to multiple instances to achieve the redundancy required for high availability. You should also distribute the instances of multiply-scaled components across different [availability zones](../customizing/understand-az.html) (AZs). If you use more than three AZs, ensure that you use an odd number of AZs. <%= vars.scaling_ert %>

<%= partial vars.scale_table %>

### <a id='single-node'></a>Unscaleable Components ###

Some components only run as a single instance, and cannot be scaled. For these singleton processes, you need to choose a different strategy besides scaling to handle events that degrade availability.

The most high-availability solution for blob storage is to use an external, third-party provider such as AWS S3, Openstack SWIFT, Google Cloud Storage, or Azure Blob Storage. But if you configure internal WebDAV or NFS to serve as your blob store, the component runs as a single node.

For these deployments, an appropriate strategy would be to use your infrastructure's high availability features to immediately recover your WebDAV or NFS Server VM if it fails. <%= vars.contact_support %>

The singleton Collector and Compilation components do not affect platform availability.

### Supporting Component Scaling

<% if vars.product_name == 'CF' %>
<%= vars.max_in_flight_header %>
<%= partial 'max_in_flight_text' %>
<% end %>
<%= vars.om_resurrector_header%>
<%= vars.om_resurrector_text%>

####Capacity####

Ensure that you allocate and maintain enough of the following:

* Free space on Diego cells so that apps expected to deploy can successfully be staged and run.
* Disk space and memory in your deployment such that if one Diego cell is down, all instances of apps can be placed on the remaining Diego cells.
* Free space to handle one AZ going down if deploying in multiple AZs.

####Resource pools####

Configure your <%=vars.pools_link%> according to the requirements of your deployment.

Each IaaS has different ways of limiting resource consumption for scaling VMs. Consult with your IaaS administrator to ensure additional VMs and related resources, like IPs and storage, will be available when scaling.

<%=vars.pcf_pools%>

#### <a id='databases'></a>Databases ####

For database services deployed outside Cloud Foundry, plan to leverage your infrastructure's high availability features and to configure backup and restore where possible. <%= vars.scaling_ert_db %>

<p class="note"><strong>Note</strong>: Data services may have single points of failure depending on their configuration.</p>

<%= vars.contact_support %>


