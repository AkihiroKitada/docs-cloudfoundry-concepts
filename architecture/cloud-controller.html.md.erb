---
title: Component&#58 Cloud Controller
owner: CAPI
---

<strong><%= modified_date %></strong>

The Cloud Controller provides REST API endpoints for clients to access the
system.
The Cloud Controller maintains a database with tables for orgs, spaces,
services, user roles, and more.

<% if vars.product_name == 'CF' %>
<%= partial 'cc_communications' %>
<% else %>
<% end %>

##<a id='auction'></a>Diego Auction ##

The Cloud Controller uses the [Diego Auction](../diego/diego-auction.html) to balance application processes over the [cells](index.html#diego-cell) in a Cloud Foundry installation.

##<a id='database'></a>Database (CC_DB) ##

<% if vars.product_name == 'OSS' %>
The Cloud Controller database has been tested with Postgres and MySQL.
<% else %>
The Cloud Controller database has been tested with MySQL.
<% end %>

##<a id='blob-store'></a>Blobstore ##

The Cloud Controller manages blobstores for the following:

* **Resources**: Files that are uploaded to the Cloud Controller with a unique
    SHA such that they can be reused without re-uploading the file

* **App Packages**: Unstaged files that represent an application

* **Droplets**: Result of taking an app package, staging it by processing a
    buildpack, and preparing it to run

* **Buildpacks**: The buildpacks available to stage apps with

* **Buildpack Cache**: Cached artifacts resulting from the staging process

The blobstore uses the [Fog](http://fog.io/) Ruby gem in order to use
services like Amazon S3, WebDAV, or the NFS filesystem for storage. 

Typically, the same blobstore is used to store all five types of blobs, but
the Cloud Controller may be configured to use a separate blobstore for each type.

1. Define blob, orphaned blob
1. Explain the problem: how blobs get orphaned and why this is bad
1. Explain how CF automatically cleans up orphaned blobs
1. Say that one could do it themselves all at once

Cloud Foundry has to manage large files, such as the bits of an app. The platform is constantly receiving, storing, bundling, and transporting these files, which are called blobs, or binary large objects. Cloud Foundry stores these blobs in a special database for large objects called a blobstore. You tell Cloud Foundry where to set up its blobstore when you configure Elastic Runtime in the File Storage pane. To learn about the types of blobs in Cloud Foundry, see the table below.

<table>
<tr>
<th>Blob Type</th>
<th>Description</th>
<th>Location in Blobstore</th>
</tr>
<tr>
<td>App Package</td>
<td>This is the full set of data for an application when it is pushed to the platform. This is the complete set of application files that is injected into the container when an application is staged.</td>
<td>`/cc-packages`</td>
</tr>
<tr>
<td>Droplet</td>
<td>This is the full output of the staging process. It includes the application bits plus any additional software that is necessary to run your application.</td>
<td>`/cc-droplets`</td>
</tr>
<tr>
<td>Buildpack</td>
<td>These are the files for all of the build packs that are installed on the platform. These are downloaded to the DEA/Diego Cell and used to stage an application.</td>
<td>`/cc-buildpacks`</td>
</tr>
<tr>
<td>Buildpack cache</td>
<td>Build packs have the ability to cache data between staging runs.  This allows them to save large downloads and other files from run-to-run, typically so that the build pack runs more quickly. Once staging is complete, the build pack's cache is persisted to the blob store.</td>
<td>`cc-droplets/buildpack_cache`</td>
</tr>
<tr>
<td>Resource Cache</td>
<td>Before the cf CLI uploads large files to the platform, it will first check with the cloud controller to see if there are cached copies of the file on the platform. It does this to save bandwidth and makes uploads take less time. The cached data is stored in the blob store.</td>
<td>`/cc-resources`</td>
</tr>
</table>

Note that when using the internal storage, these directories will be located at `/var/vcap/store/shared.`

##<a id='nats'></a>NATS Messaging ##

The Cloud Controller interacts with other core components of the Cloud Foundry
platform using the NATS message bus.
For example, the Cloud Controller uses NATS when performing the following
interactions:

* Instructing a cell to stage an application by processes a buildpack for the app
    and to prepare it to run
* Instructing a cell to start or stop an application
* Receiving information from the Health Manager about applications
* Subscribing to Service Gateways that advertise available services
* Instructing Service Gateways to handle provisioning, unprovisioning, binding,
    and unbinding operations for services

##<a id='testing'></a>Testing ##

<% if vars.product_name == 'OSS' %>

By default `rspec` runs a test suite with the SQLite in-memory database.
Specify a connection string using the `DB_CONNECTION` environment variable to
test against Postgres and MySQL. For example:

~~~
    DB_CONNECTION="postgres://postgres@localhost:5432/ccng" rspec
    DB_CONNECTION="mysql2://root:password@localhost:3306/ccng" rspec
~~~

Travis currently runs two build jobs against Postgres and MySQL.

<% else %>

By default `rspec` runs a test suite with the SQLite in-memory database.
Specify a connection string using the `DB_CONNECTION` environment variable to
test against MySQL. For example:

~~~
    DB_CONNECTION="mysql2://root:password@localhost:3306/ccng" rspec
~~~

<% end %>

<%= vars.cloud_controller_logging %>
