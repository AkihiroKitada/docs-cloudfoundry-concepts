---
title: Component&#58 Cloud Controller
owner: CAPI
---

<strong><%= modified_date %></strong>

The Cloud Controller provides REST API endpoints for clients to access the
system.
The Cloud Controller maintains a database with tables for orgs, spaces,
services, user roles, and more.

<% if vars.product_name == 'CF' %>
<%= partial 'cc_communications' %>
<% else %>
<% end %>

##<a id='auction'></a>Diego Auction

The Cloud Controller uses the [Diego Auction](../diego/diego-auction.html) to balance application processes over the [cells](index.html#diego-cell) in a Cloud Foundry installation.

##<a id='database'></a>Database (CC_DB)

<% if vars.product_name == 'OSS' %>
The Cloud Controller database has been tested with Postgres and MySQL.
<% else %>
The Cloud Controller database has been tested with MySQL.
<% end %>

##<a id='blob-store'></a>Blobstore

Cloud Foundry handles and stores binary large object (blob) files for the following:

<table>
<tr>
<th>Blob Type</th>
<th>Description</th>
<th>Location in Blobstore</th>
</tr>
<tr>
<td>App Packages</td>
<td>App source directory contents.</td>
<td>`/cc-packages`</td>
</tr>
<tr>
<td>Buildpacks</td>
<td>Buildpacks to compile and stage apps with. These are downloaded to the Diego Cell that stages the app.</td>
<td>`/cc-buildpacks`</td>
</tr>
<tr>
<td>Resource Cache</td>
<td>Large files from app packages that the Cloud Controller stores with a SHA for later re-use. To save bandwidth, the Cloud Foundry Command-Line Interface (cf CLI) only uploads large application files that the Cloud Controller has not already stored in the resource cache.</td>
<td>`/cc-resources`</td>
</tr>
<tr>
<td>Buildpack Cache</td>
<td>Large files generated by the buildpack, stored for later re-use to enable buildpacks to run more quickly when staging apps that Diego cells have already built.</td>
<td>`cc-droplets/buildpack_cache`</td>
</tr>
<tr>
<td>Droplets</td>
<td>Staged apps packaged with everything needed to run in a container.</td>
<td>`/cc-droplets`</td>
</tr>
</table>

A single blobstore typically stores all five types of blobs, but you can configure the Cloud Controller to use a separate blobstore for each type.

Cloud Foundry blobstores use the [Fog](http://fog.io/) Ruby gem to store blobs in
services like Amazon S3, WebDAV, or the NFS filesystem. The file system location of an internal blobstore is `/var/vcap/store/shared.`

###<a id='orphan-blobs'></a>Orphan Blobs

When a blob delete fails silently or something else goes wrong, the blobstore may continue to contain blobs that the Cloud Controller no longer needs or lists in its database. These are called orphan blobs, and they waste blobstore capacity.

The Cloud Controller detects and removes orphan blobs by scanning part of the blobstore daily and checking for blobs that its database does not account for. The process scans through the entire blobstore every week, and only removes blobs that show as orphans for three consecutive days. The Cloud Controller performs this automatic cleanup when the `cloud_controller_worker` job property `cc.perform_blob_cleanup` is set to `true`.

###<a id='manual-blob-cleanup'></a>Manual Blob Cleanup


##<a id='nats'></a>NATS Messaging

The Cloud Controller interacts with other core components of the Cloud Foundry
platform using the NATS message bus.
For example, the Cloud Controller uses NATS when performing the following
interactions:

* Instructing a cell to stage an application by processes a buildpack for the app
    and to prepare it to run
* Instructing a cell to start or stop an application
* Receiving information from the Health Manager about applications
* Subscribing to Service Gateways that advertise available services
* Instructing Service Gateways to handle provisioning, unprovisioning, binding,
    and unbinding operations for services

##<a id='testing'></a>Testing

<% if vars.product_name == 'OSS' %>

By default `rspec` runs a test suite with the SQLite in-memory database.
Specify a connection string using the `DB_CONNECTION` environment variable to
test against Postgres and MySQL. For example:

~~~
    DB_CONNECTION="postgres://postgres@localhost:5432/ccng" rspec
    DB_CONNECTION="mysql2://root:password@localhost:3306/ccng" rspec
~~~

Travis currently runs two build jobs against Postgres and MySQL.

<% else %>

By default `rspec` runs a test suite with the SQLite in-memory database.
Specify a connection string using the `DB_CONNECTION` environment variable to
test against MySQL. For example:

~~~
    DB_CONNECTION="mysql2://root:password@localhost:3306/ccng" rspec
~~~

<% end %>

<%= vars.cloud_controller_logging %>
