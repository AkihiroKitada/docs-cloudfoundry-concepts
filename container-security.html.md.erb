---
title: Understanding Container Security
owner: Security
---

<strong><%= modified_date %></strong>

This topic describes how Cloud Foundry (CF) secures the containers that host application instances. For an overview of other CF security features, see the [Understanding Cloud Foundry Security](security.html) topic.

* [Container Mechanics](#mechanics) provides an overview of container isolation. 
* [Container Networking](#networking) describes container networking and how CF administrators [customize](#config-traffic) container network traffic rules for their deployment. 
* [Container Security](#security) describes how CF secures containers by assigning application instances to [unprivileged or privileged](#types) containers and by [hardening](#hardening) them.

## <a id='mechanics'></a>Container Mechanics###

Each instance of an application deployed to CF runs within its own self-contained environment, a [Garden container](./diego/diego-architecture.html#garden) that isolates processes, memory, and the filesystem. CF isolates all containers from each other using operating system features and the characteristics of the virtual and physical infrastructure where CF is deployed. 

### <a id='isolation'></a>Container Isolation

Container isolation is achieved by namespacing kernel resources that would otherwise be shared. The intended level of isolation is set such that multiple containers present on the same host cannot detect each other. Every container includes a private root filesystem – each container has its own Process ID (PID), namespace, network namespace, and mount namespace.

This container filesystem is created by stacking a read-only base filesystem and a container-specific read-write filesystem, commonly known as an overlay filesystem. The read-only filesystem contains the minimal set of operating system packages and Garden-specific modifications common to all containers. Containers can share the same read-only base filesystem because all writes are applied to the read-write filesystem. The read-write filesystem is unique to each container and is created by formatting a large sparse file of a fixed size. This fixed size prevents the read-write filesystem from overflowing into unallocated space.

Resource control is managed using Linux control groups ([cgroups](https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt)) or Windows [job objects](https://msdn.microsoft.com/en-us/library/windows/desktop/ms684161(v=vs.85).aspx). Associating each container with its own cgroup or job object limits the amount of memory that the container may use. Linux cgroups also require the container to use a fair share of CPU compared to the relative CPU share of other containers. 

<p class="note">
    <strong>Note</strong>: BOSH does not support a RedHat Enterprise Linux OS stemcell. This is due to an inherent security issue with the way RedHat handles user namespacing and container isolation.
</p>

## <a id='networking'></a>Container Networking ##

To isolate applications and control outgoing traffic, each Garden container uses a dedicated virtual network interface (VNI) that consists of a pair of Ethernet addresses: one visible to the application instance running in the container, and the other visible to the host VM’s root namespace. The pair is configured to use IPs in a small and static subnet. Applications are typically allowed to invoke other applications in CF only by leaving the system and re-entering through the load balancer positioned in front of the CF routers. 

When an application instance starts, the [Diego cell](./diego/diego-architecture.html#cell-components) (or [DEA](./architecture/execution-agent.html)) on the host VM allocates an IP address and assigns an arbitrary port to the application container. The application uses the `PORT` environment variable provided in the container environment to determine which port to listen on. Because the host assigns a random value to the `PORT` environment variable, the value is generally unique for each application instance.

A host VM has a single IP address. If you configure the deployment with the cluster on a VLAN, as recommended, then all traffic goes through the following levels of network address translation, as shown in the diagram below.

* <strong>Inbound</strong> requests flow from the load balancer through the router to the host cell (or DEA), then into the application container. The router determines which application instance receives each request.

* <strong>Outbound</strong> traffic flows from the application container to the cell (or DEA), then to the gateway on the cell's virtual network interface. This gateway might be a NAT to external networks depending on your IaaS.

  <%= image_tag("images/security/sysbound2.png") %>

### <a id='config-traffic'></a>Container Network Traffic Rules ###

Administrators can configure rules to govern container network traffic. These rules can prevent system access from external networks and between internal components, and restrict applications from establishing connections over the virtual network interface.

Administrators configure these rules at two levels: 

* [Application Security Groups](#asg) apply network traffic rules at the container level.
* [Network Properties](#network-properties) of cells (or DEAs) apply network traffic rules at the host VM level.

#### <a id='asg'></a>Application Security Groups ####

CF blocks all outbound network connections from application containers by default. Administrators can override this behavior by configuring ASGs to specify egress access rules for applications.

To target applications with specific network traffic rules, ASGs define traffic rules for individual containers. The rules specify the protocols, addresses, and ports that are allowed for outgoing traffic. Because they are “allow” rules, their order of evaluation is unimportant when multiple application security groups apply to the same space, org, or deployment. The cell uses these rules to filter and log outbound network traffic.

When applications are first staging, they need traffic rules loose enough to let them pull resources in from across the network. Once they are running, the traffic rules can be more restrictive and secure. To distinguish between these two security needs, administrators can define one ASG for when an application stages, and a different one for when it runs. To provide granular control in securing a deployment, an administrator can also assign ASGs to apply across a CF deployment, or to specific spaces or orgs within a deployment. 

<%=vars.app_sec_groups_link%>

#### <a id='network-properties'></a>Host-level Network Properties ####

Operators can configure the `allow_networks` and `deny_networks` parameters for cells (or DEAs) to restrict communication between system components and applications. 

To configure host-level network properties, edit the following properties in your Diego manifest and redeploy:

```
  garden.deny_networks:
    description: "List of CIDR blocks to which containers will be denied access."
    default: []

  garden.allow_networks:
    description: "List of CIDR blocks to which containers will be allowed access (applied after deny)."
    default: []
```

<p class="note"><strong>Note</strong>: ASGs provide a greater degree of security than host-level network properties. ASGs enable you to more securely restrict application outbound traffic to predefined routes. ASGs also overwrite any host-level configurations.</p> 

To configure host-level network properties for DEAs, see <%=vars.dea_properties%>.

## <a id='security'></a>Container Security###

CF secures containers through the following measures:

* Assigning application instances to [unprivileged](#unprivileged) or [privileged](#privileged) containers depending on the workload or application type.
* [Hardening](#hardening) containers by limiting functionality and access rights.
* Blocking all outbound network connections from application containers by default. Administrators can override this behavior by [configuring Application Security Groups](#asg) (ASGs).

### <a id="types"></a> Container Types

Garden has two container types: unprivileged and privileged. CF determines which container type to use depending on the workload or application type.

#### <a id="unprivileged"></a> Unprivileged Containers

Applications based on Docker images run in unprivileged containers. Because Docker images come with their own root filesystem and user, CF cannot trust the root filesystem and cannot assume that the container user process will never be root. For that reason, CF runs applications based on Docker images in unprivileged containers. See [Using Docker in Cloud Foundry](docker.html) for more information about using Docker.

#### <a id="privileged"></a> Privileged Containers

Buildpack-based applications, as well as [staging tasks](how-applications-) for both buildpack and Docker image applications, run in privileged containers that use the cflinuxfs2 root filesystem. Because all processes invoked in these containers are run as the unprivileged user `vcap`, CF runs the containers as privileged.

### <a id='hardening'></a> Container Hardening

CF does the following to mitigate against container breakout and denial of service attacks:

* CF uses the full set of [Linux namespaces](http://manpages.ubuntu.com/manpages/wily/man7/namespaces.7.html) (IPC, Network, Mount, PID, User, UTS) to provide isolation between containers running on the same host. The User namespace is not used for privileged containers.
* In unprivileged containers, CF maps UID/GID 0 (root) inside the container user namespace to a different UID/GID on the host to prevent an application from inheriting UID/GID 0 on the host if it breaks out of the container. 
	* CF uses the same UID/GID for all containers.
    * CF maps all UIDs except UID 0 to themselves. CF maps UID 0 inside the container namespace to `MAX_UID-1` outside of the container namespace.
    * Container Root does not grant Host Root permissions.
* CF mounts `/proc` and `/sys` as read-only inside containers.
* CF disallows `dmesg` access for unprivileged users and all users in unprivileged containers.
* CF uses `chroot` when importing docker images from docker registries.
* CF establishes a container-specific overlay filesystem mount and uses [`pivot_root`](http://manpages.ubuntu.com/manpages/trusty/man2/pivot_root.2.html) to move the root filesystem into that overlay to isolate the container from the host system’s filesystem.
* CF eliminates any dependencies on scripts and binaries inside the root filesystem, by not calling any binary or script inside the container filesystem.
* CF avoids side-loading binaries in the container, through bind mounts or other methods. Instead, it re-executes the same binary by reading it from `/proc/self/exe` whenever it needs to run a binary in a container.
* CF establishes a a virtual ethernet pair for each container for its network traffic. See the [Container Network Traffic](#traffic) section above for more information.
    * One interface in the pair is inside the container’s network namespace, and is the only non-loopback interface accessible inside the container.
    * The other interface remains in the host network namespace and is bridged to the container-side interface.
    * Egress whitelist rules are applied to these interfaces according to [ASGs](#asg) configured by the administrator.
    * First-packet logging rules may also be enabled on TCP whitelist rules.
    * DNAT rules are established on the host to enable traffic ingress from the host interface to whitelisted ports on the container-side interface.
* CF applies disk quotas by confining container-specific filesystem layers to loop devices with the specified disk-quota capacity.
* CF applies a total memory usage quota through the memory cgroup and destroys the container if the memory usage exceeds the quota.
* CF applies a fair-use limit to CPU usage for processes inside the container through the `cpu.shares` control group.
* CF limits access to devices using cgroups but explicitly whitelists the following safe device nodes:
	* `/dev/full`
	* `/dev/fuse`
	* `/dev/null`
	* `/dev/ptmx`
	* `/dev/pts/*`
	* `/dev/random`
	* `/dev/tty`
	* `/dev/tty0`
	* `/dev/tty1`
	* `/dev/urandom`
	* `/dev/zero`
	* `/dev/tap`
	* `/dev/tun`
* CF drops the following [Linux capabilities](http://manpages.ubuntu.com/manpages/wily/man7/capabilities.7.html) for all container processes. Every dropped capability limits what actions the root user can perform.
	* `CAP\_DAC\_READ\_SEARCH`
	* `CAP\_LINUX\_IMMUTABLE`
	* `CAP\_NET\_BROADCAST`
	* `CAP\_NET\_ADMIN`
	* `CAP\_IPC\_LOCK`
	* `CAP\_IPC\_OWNER`
	* `CAP\_SYS\_MODULE`
	* `CAP\_SYS\_RAWIO`
	* `CAP\_SYS\_PTRACE`
	* `CAP\_SYS\_PACCT`
	* `CAP\_SYS\_BOOT`
	* `CAP\_SYS\_NICE`
	* `CAP\_SYS\_RESOURCE`
	* `CAP\_SYS\_TIME`
	* `CAP\_SYS\_TTY\_CONFIG`
	* `CAP\_LEASE`
	* `CAP\_AUDIT\_CONTROL`
	* `CAP\_MAC\_OVERRIDE`
	* `CAP\_MAC\_ADMIN`
	* `CAP\_SYSLOG`
	* `CAP\_WAKE\_ALARM`
	* `CAP\_BLOCK\_SUSPEND`
	* `CAP\_SYS\_ADMIN` (for unprivileged containers)

